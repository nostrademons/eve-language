typedef Iterable: {
    get: (Iterable -> Any),
    next: (Iterable -> Iterable),
    is_valid: (Iterable -> Bool)
}

class Iterable:
    'Any object that can produce an iterator'
    def iter(self): self
    # TODO: figure out ways to easily proxy the methods on Iterator down to
    # calls on the Iterable, eg. Iterable.reduce = {| self, *args |
    # self.iter().reduce(*args) }

class Iterator(Iterable):
    class cycle(ProxyIterator):
        """
        Cycles through the iterator elements, returning to the first one when
        the iterator is exhausted.
        """
        def init(self): 
            i = self.iter()
            { self: i, start: i }
        def next(self):
            if super(self).is_valid(self) 
                then super(self).next(self) 
                else self | { original: start }
        def is_valid(self): True

    class map(ProxyIterator):
        def init(self, f): { original: self.iter(), f: ignore_self(f) }
        def get(self): self.f(super(self).get())

    class filter(ProxyIterator):
        def next_legal(self):
            next_iter = super(self).next
            if self.pred(next_iter.get()) then next_iter else next__legal(next_iter)
        def init(self, pred): 
            next_legal({ original: self, pred: ignore_self(pred) })
        def next(self): self | { original: next_legal(self) }

    class take_while(ProxyIterator):
        def init(self, pred):  { 
            original: self, 
            pred: ignore_receiver(pred)
        }
        def is_valid(self): super(self).is_valid() and self.pred(self.next().get())

    class take(take_while):
        def init(self, num): { 
            original: self,
            index: 0,
            pred: {| self, val | self.index < num }
        }
        def next(self): super(self).next() | { index: self.index + 1 }

    class drop_while(ProxyIterator):
        def init(self, pred):
            if pred(self.get())
                then init(self.next(), pred)
                else { original: self }

    class drop(ProxyIterator):
        def init(self, num):
            if num > 0 and self.is_valid()
                then init(self.next(), num - 1)
                else { original: self }

    def slice(self, start, end):
        drop(self, start) -> take(?, end - start)

    def reduce(self, f, accum):
        if self.is_valid()
            then self.next().reduce(f, f(self.get(), accum))
            else accum

    def search(self, pred, index=0): 
        cond:
            pred(self.get()): index
            self.is_valid(): self.next().search(pred, index + 1)
            True: -1

    def len(self): self.reduce({| val, len | len + 1 }, 0)
    def find(self, val): self.search(? == val)
    def contains(self, val): self.find(val) != -1
    def any(self, pred=Bool): self.search({| val | pred(val) == True }) != -1
    def all(self, pred=Bool): self.search({| val | pred(val) == False }) == -1
    def min(self): self.reduce({| val, last | if val < last then val else last }, self.get())
    def max(self): self.reduce({| val, last | if val > last then val else last }, self.get())

class ProxyIterator(Iterator):
    """
    An iterator that proxies calls through to an underlying iterator.  Used as
    a base class for many of the functions here.
    """
    def init(original): { original: original.iter() }
    def get(self): self.original.get()
    def next(self): self | { original: self.original.next() }
    def is_valid(self): self.original.is_valid()

class chain(Iterator):
    """
    Produces an iterator that runs through each of its arguments in turn.
    The arguments may be either sequences or iterators themselves.

    Eve>>> chain([1,2]).get()
    1
    Eve>>> chain([1,2]).next().next().is_valid()
    False

    """
    def init(current, *rest): { 
        current: current.iter(),
        rest: rest
    }
    def get(self): self.current.get()
    def next(self):
        if self.current.is_valid() 
            then self | { current: self.current.next() }
            else self | { 
                current: self.rest[0].iter(), 
                rest: self.rest[1 : self.rest.len()] 
            }
    def is_valid(self): self.current.is_valid() or self.rest.len() > 0

class repeat(Iterator):
    def init(value): locals()
    def get(self): self.value
    def next(self): self
    def is_valid(self): True

class iterate(Iterator):
    def init(initial, f): { current: initial, f: ignore_self(f) }
    def get(self): self.current
    def next(self): self | { current: self.f(self.current) }
    def is_valid(self): self.f(self.current) != None

