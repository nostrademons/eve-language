import eve.lang.class

typedef Iterable: {
    get: (Iterable -> Any),
    next: (Iterable -> Iterable),
    has_next: (Iterable -> Bool)
}

Iterable = make_class('Iterable', 'Any object that can produce an iterator',
                        Object, { iter: id })

class ProxyIterator(Iterable):
    def init(original): add_superclass(Iterator, { original: original.iter() })
    def get(self): self.original.get()
    def next(self): self | { original: self.original.next() }
    def has_next(self): self.original.has_next()

class chain(ProxyIterator):
    def init(*iterables): 
        master = iterables.iter()
        ProxyIterator.init(master.get()) | { master: master }
    def next(self):
        if super(self).has_next() 
            then self | { original: super(self).next() }
            else chain(*self.master.next())
    def has_next(self):
        super(self).has_next() or self.master.has_next()

class repeat(Iterable):
    def init(value): locals()
    def get(self): self.value
    def next(self): self
    def has_next(self): True

class iterate(Iterable):
    def init(initial, f): { current: initial, f: ignore_self(f) }
    def get(self): self.current
    def next(self): self | { current: self.f(self.current) }
    def has_next(self): True

class Iterator(Iterable):
    class cycle(ProxyIterator):
        def init(self): 
            i = self -> iter
            { self: i, start: i }
        def next(self):
            if super(self).has_next(self) 
                then super(self).next(self) 
                else self | { original: start }
        def has_next(self): True

    class map(ProxyIterator):
        def init(self, f): { original: original -> iter, f: ignore_self(f) }
        def get(self): return self.f(super(self).get())
        make_class(ProxyIterator, locals())

    class filter(ProxyIterator):
        def next_legal(self):
            next_iter = super(self).next
            if self.pred(next_iter.get()) then next_iter else next__legal(next_iter)
        def init(self, pred): 
            next_legal({ original: self, pred: ignore_self(pred) })
        def next(self): self | { original: next_legal(self) }

    class take_while(ProxyIterator):
        def init(self, pred):  { 
            original: self, 
            pred: ignore_receiver(pred),
        }
        def has_next(self): super(self).has_next() and self.pred(self.next().get())

    class take(take_while):
        def init(self, num): { 
            original: self,
            index: 0,
            pred: {| self, val | self.index < num }
        }
        def next(self): super(self).next() | { index: self.index + 1 }

    class drop_while(ProxyIterator):
        def init(self, pred):
            if pred(self.get())
                then init(self.next(), pred)
                else { original: self }

    class drop(ProxyIterator):
        def init(self, num):
            if num > 0 and self.has_next()
                then init(self.next(), num - 1)
                else { original: self }

    def slice(self, start, end):
        drop(self, start) -> take(?, end - start)

    def reduce(self, f, accum, breakout=constant(False), not_found=None):
        i = self.iter()
        cond:
            breakout(i.get()): accum
            i.has_next(): i.next().reduce(f(i.get(), accum)
            True: not_found

    def len(self): self.reduce(? + 1, 0)
    def find(self, val): self.reduce(? + 1, 0, ? == val, -1)
    def contains(self, val): self.find(val) != -1
    def any(self, pred=Bool): self.reduce(constant(True), True, ? == True, False)
    def all(self, pred=Bool): self.reduce(constant(True), True, ? == False, True)
    def min(self): self.reduce({| val, last | if val < last then val else last }, self[0])
    def max(self): self.reduce({| val, last | if val > last then val else last }, self[0])
