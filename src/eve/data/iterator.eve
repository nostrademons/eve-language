typedef Iterable: {
    get: (Iterable -> Any),
    next: (Iterable -> Iterable),
    has_next: (Iterable -> Bool)
}

class Iterable:
    'Any object that can produce an iterator'
    def iter(self): self
    # TODO: figure out ways to easily proxy the methods on Iterator down to
    # calls on the Iterable, eg. Iterable.reduce = {| self, *args |
    # self.iter().reduce(*args) }

class ProxyIterator(Iterable):
    '''
    An iterator that proxies calls through to an underlying iterator.  Used as
    a base class for many of the functions here.
    '''
    def init(original): add_superclass(Iterator, { original: original.iter() })
    def get(self): self.original.get()
    def next(self): self | { original: self.original.next() }
    def has_next(self): self.original.has_next()

class chain(ProxyIterator):
    def init(current, *rest): add_superclass(Iterator, { 
        original: current.iter(),
        rest: rest
    })
    def next(self):
        if self.original.has_next() 
            then self | { original: self.original.next() }
            else self | { original: self.rest[0], rest: self.rest[1 : self.rest.len()] }
    def has_next(self): self.original.has_next() or self.rest.len() > 0

class repeat(Iterable):
    def init(value): locals()
    def get(self): self.value
    def next(self): self
    def has_next(self): True

class iterate(Iterable):
    def init(initial, f): { current: initial, f: ignore_self(f) }
    def get(self): self.current
    def next(self): self | { current: self.f(self.current) }
    def has_next(self): self.f(self.current) != None

class Iterator(Iterable):
    class cycle(ProxyIterator):
        def init(self): 
            i = self -> iter
            { self: i, start: i }
        def next(self):
            if super(self).has_next(self) 
                then super(self).next(self) 
                else self | { original: start }
        def has_next(self): True

    class map(ProxyIterator):
        def init(self, f): { original: original -> iter, f: ignore_self(f) }
        def get(self): self.f(super(self).get())
        make_class(ProxyIterator, locals())

    class filter(ProxyIterator):
        def next_legal(self):
            next_iter = super(self).next
            if self.pred(next_iter.get()) then next_iter else next__legal(next_iter)
        def init(self, pred): 
            next_legal({ original: self, pred: ignore_self(pred) })
        def next(self): self | { original: next_legal(self) }

    class take_while(ProxyIterator):
        def init(self, pred):  { 
            original: self, 
            pred: ignore_receiver(pred)
        }
        def has_next(self): super(self).has_next() and self.pred(self.next().get())

    class take(take_while):
        def init(self, num): { 
            original: self,
            index: 0,
            pred: {| self, val | self.index < num }
        }
        def next(self): super(self).next() | { index: self.index + 1 }

    class drop_while(ProxyIterator):
        def init(self, pred):
            if pred(self.get())
                then init(self.next(), pred)
                else { original: self }

    class drop(ProxyIterator):
        def init(self, num):
            if num > 0 and self.has_next()
                then init(self.next(), num - 1)
                else { original: self }

    def slice(self, start, end):
        drop(self, start) -> take(?, end - start)

    def reduce(self, f, accum):
        if self.has_next()
            then self.next().reduce(f, f(self.get(), accum))
            else accum

    def search(self, pred, index=0): 
        cond:
            pred(self.get()): index
            self.has_next(): self.next().search(pred, index + 1)
            True: -1

    def len(self): self.reduce({| val, len | len + 1 }, 0)
    def find(self, val): self.search(? == val)
    def contains(self, val): self.find(val) != -1
    def any(self, pred=Bool): self.search({| val | pred(val) == True }) != -1
    def all(self, pred=Bool): self.search({| val | pred(val) == False }) == -1
    def min(self): self.reduce({| val, last | if val < last then val else last }, self.get())
    def max(self): self.reduce({| val, last | if val > last then val else last }, self.get())
